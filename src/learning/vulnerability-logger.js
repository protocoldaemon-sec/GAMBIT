/**
 * Vulnerability Logger
 * Continuous security and logic analysis
 * 
 * Logs vulnerabilities for the self-healing agent to fix
 */
import { supabase, TABLES } from "../supabase/client.js";
import crypto from "crypto";

export class VulnerabilityLogger {
  constructor(config = {}) {
    this.severityLevels = ["LOW", "MEDIUM", "HIGH", "CRITICAL"];
    this.categories = [
      "SECURITY",
      "BUSINESS_LOGIC",
      "PERFORMANCE",
      "DATA_INTEGRITY",
      "RISK_MANAGEMENT",
      "CODE_QUALITY",
    ];
    
    this.vulnerabilities = [];
    this.fixedVulnerabilities = [];
    this.analysisHistory = [];
  }

  /**
   * Log a vulnerability
   */
  async log(vulnerability) {
    const vuln = {
      id: crypto.randomUUID(),
      timestamp: new Date().toISOString(),
      severity: vulnerability.severity || "MEDIUM",
      category: vulnerability.category || "CODE_QUALITY",
      title: vulnerability.title,
      description: vulnerability.description,
      location: vulnerability.location, // file:line or component
      impact: vulnerability.impact,
      recommendation: vulnerability.recommendation,
      status: "OPEN",
      autoFixable: vulnerability.autoFixable || false,
      fixPriority: this.calculatePriority(vulnerability),
      metadata: vulnerability.metadata || {},
    };
    
    this.vulnerabilities.push(vuln);
    
    // Store in database
    try {
      await supabase.from(TABLES.VULNERABILITIES || "vulnerabilities").insert(vuln);
    } catch (error) {
      console.error("[VulnLogger] Failed to store vulnerability:", error.message);
    }
    
    console.log(`[VulnLogger] ${vuln.severity}: ${vuln.title} (${vuln.category})`);
    
    return vuln;
  }

  /**
   * Calculate fix priority based on severity and impact
   */
  calculatePriority(vuln) {
    const severityScore = {
      CRITICAL: 100,
      HIGH: 75,
      MEDIUM: 50,
      LOW: 25,
    }[vuln.severity] || 50;
    
    const categoryScore = {
      SECURITY: 1.5,
      RISK_MANAGEMENT: 1.3,
      BUSINESS_LOGIC: 1.2,
      DATA_INTEGRITY: 1.1,
      PERFORMANCE: 1.0,
      CODE_QUALITY: 0.8,
    }[vuln.category] || 1.0;
    
    return Math.round(severityScore * categoryScore);
  }

  /**
   * Analyze code for security vulnerabilities
   */
  async analyzeSecurityVulnerabilities(code, filename) {
    const findings = [];
    
    // Check for hardcoded secrets
    const secretPatterns = [
      { pattern: /['"]sk-[a-zA-Z0-9]{20,}['"]/, name: "Hardcoded API Key" },
      { pattern: /['"][a-f0-9]{64}['"]/, name: "Potential Private Key" },
      { pattern: /password\s*=\s*['"][^'"]+['"]/, name: "Hardcoded Password" },
      { pattern: /secret\s*=\s*['"][^'"]+['"]/, name: "Hardcoded Secret" },
    ];
    
    for (const { pattern, name } of secretPatterns) {
      if (pattern.test(code)) {
        findings.push({
          severity: "CRITICAL",
          category: "SECURITY",
          title: name,
          description: `Found ${name.toLowerCase()} in ${filename}`,
          location: filename,
          impact: "Credentials could be exposed in version control",
          recommendation: "Use environment variables instead",
          autoFixable: true,
        });
      }
    }
    
    // Check for SQL injection vulnerabilities
    if (/\$\{.*\}.*(?:SELECT|INSERT|UPDATE|DELETE)/i.test(code)) {
      findings.push({
        severity: "HIGH",
        category: "SECURITY",
        title: "Potential SQL Injection",
        description: "String interpolation in SQL query detected",
        location: filename,
        impact: "Database could be compromised",
        recommendation: "Use parameterized queries",
        autoFixable: false,
      });
    }
    
    // Check for eval usage
    if (/\beval\s*\(/.test(code)) {
      findings.push({
        severity: "HIGH",
        category: "SECURITY",
        title: "Dangerous eval() Usage",
        description: "eval() can execute arbitrary code",
        location: filename,
        impact: "Remote code execution vulnerability",
        recommendation: "Replace eval with safer alternatives",
        autoFixable: false,
      });
    }
    
    // Log all findings
    for (const finding of findings) {
      await this.log(finding);
    }
    
    return findings;
  }

  /**
   * Analyze business logic vulnerabilities
   */
  async analyzeBusinessLogic(code, filename) {
    const findings = [];
    
    // Check for missing input validation
    if (/async.*\(.*\)\s*{[^}]*(?:amount|price|size)/.test(code) && 
        !/(?:isNaN|Number\.isFinite|typeof.*number|z\.number)/.test(code)) {
      findings.push({
        severity: "MEDIUM",
        category: "BUSINESS_LOGIC",
        title: "Missing Numeric Validation",
        description: "Financial values may not be validated",
        location: filename,
        impact: "Invalid trades could be executed",
        recommendation: "Add numeric validation for amount/price/size",
        autoFixable: true,
      });
    }
    
    // Check for missing error handling
    if (/await\s+\w+\(/.test(code) && !/try\s*{/.test(code)) {
      findings.push({
        severity: "LOW",
        category: "BUSINESS_LOGIC",
        title: "Missing Error Handling",
        description: "Async operations without try-catch",
        location: filename,
        impact: "Unhandled errors could crash the system",
        recommendation: "Wrap async operations in try-catch",
        autoFixable: true,
      });
    }
    
    // Check for division without zero check
    if (/\/\s*(?:\w+|\([^)]+\))/.test(code) && !/(?:\|\|\s*1|===?\s*0|\+ 1e-10)/.test(code)) {
      findings.push({
        severity: "MEDIUM",
        category: "BUSINESS_LOGIC",
        title: "Potential Division by Zero",
        description: "Division operation without zero check",
        location: filename,
        impact: "Could cause NaN or Infinity in calculations",
        recommendation: "Add zero check or default value",
        autoFixable: true,
      });
    }
    
    for (const finding of findings) {
      await this.log(finding);
    }
    
    return findings;
  }

  /**
   * Analyze risk management vulnerabilities
   */
  async analyzeRiskManagement(positions, config) {
    const findings = [];
    
    // Check for position concentration
    const totalValue = positions.reduce((sum, p) => sum + p.size, 0);
    for (const position of positions) {
      const concentration = position.size / totalValue;
      if (concentration > 0.5) {
        findings.push({
          severity: "HIGH",
          category: "RISK_MANAGEMENT",
          title: "High Position Concentration",
          description: `Position ${position.ticker} is ${(concentration * 100).toFixed(1)}% of portfolio`,
          location: `position:${position.id}`,
          impact: "Single position failure could cause significant loss",
          recommendation: "Reduce position size or diversify",
          autoFixable: false,
          metadata: { ticker: position.ticker, concentration },
        });
      }
    }
    
    // Check for missing stop loss
    for (const position of positions) {
      if (!position.stop_loss) {
        findings.push({
          severity: "MEDIUM",
          category: "RISK_MANAGEMENT",
          title: "Missing Stop Loss",
          description: `Position ${position.ticker} has no stop loss`,
          location: `position:${position.id}`,
          impact: "Unlimited downside risk",
          recommendation: "Set stop loss at appropriate level",
          autoFixable: true,
          metadata: { ticker: position.ticker },
        });
      }
    }
    
    // Check for excessive leverage
    const leverage = totalValue / (config.portfolioValue || totalValue);
    if (leverage > 2) {
      findings.push({
        severity: "CRITICAL",
        category: "RISK_MANAGEMENT",
        title: "Excessive Leverage",
        description: `Portfolio leverage is ${leverage.toFixed(2)}x`,
        location: "portfolio",
        impact: "Amplified losses could exceed capital",
        recommendation: "Reduce total position sizes",
        autoFixable: false,
        metadata: { leverage },
      });
    }
    
    for (const finding of findings) {
      await this.log(finding);
    }
    
    return findings;
  }

  /**
   * Mark vulnerability as fixed
   */
  async markFixed(vulnId, fixDetails) {
    const vuln = this.vulnerabilities.find(v => v.id === vulnId);
    if (!vuln) return null;
    
    vuln.status = "FIXED";
    vuln.fixedAt = new Date().toISOString();
    vuln.fixDetails = fixDetails;
    
    this.fixedVulnerabilities.push(vuln);
    this.vulnerabilities = this.vulnerabilities.filter(v => v.id !== vulnId);
    
    try {
      await supabase.from(TABLES.VULNERABILITIES || "vulnerabilities")
        .update({
          status: "FIXED",
          fixed_at: vuln.fixedAt,
          fix_details: fixDetails,
        })
        .eq("id", vulnId);
    } catch (error) {
      console.error("[VulnLogger] Failed to update vulnerability:", error.message);
    }
    
    console.log(`[VulnLogger] Fixed: ${vuln.title}`);
    return vuln;
  }

  /**
   * Get open vulnerabilities sorted by priority
   */
  getOpenVulnerabilities() {
    return this.vulnerabilities
      .filter(v => v.status === "OPEN")
      .sort((a, b) => b.fixPriority - a.fixPriority);
  }

  /**
   * Get vulnerabilities by category
   */
  getByCategory(category) {
    return this.vulnerabilities.filter(v => v.category === category);
  }

  /**
   * Get summary statistics
   */
  getSummary() {
    const open = this.vulnerabilities.filter(v => v.status === "OPEN");
    
    return {
      total: this.vulnerabilities.length,
      open: open.length,
      fixed: this.fixedVulnerabilities.length,
      bySeverity: {
        CRITICAL: open.filter(v => v.severity === "CRITICAL").length,
        HIGH: open.filter(v => v.severity === "HIGH").length,
        MEDIUM: open.filter(v => v.severity === "MEDIUM").length,
        LOW: open.filter(v => v.severity === "LOW").length,
      },
      byCategory: Object.fromEntries(
        this.categories.map(cat => [cat, open.filter(v => v.category === cat).length])
      ),
      autoFixable: open.filter(v => v.autoFixable).length,
    };
  }

  /**
   * Export vulnerabilities for reporting
   */
  exportReport() {
    return {
      generatedAt: new Date().toISOString(),
      summary: this.getSummary(),
      openVulnerabilities: this.getOpenVulnerabilities(),
      recentlyFixed: this.fixedVulnerabilities.slice(-10),
    };
  }
}

export default VulnerabilityLogger;
